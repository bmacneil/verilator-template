// ***************************
// Date:
// Author:
// Module Name: MODULENAME
// Description:
// ***************************
#include <doctest.h>
#include "verilated.h"
#include <verilated_vcd_c.h>
// Included with project
#include "include/Testbench.hpp"
//Generated by verilator
#include "VMODULENAME.h"
// Generated by python script
#include "include/port.hpp"
// Std library
#include <iostream>
#include <string>

using std::string;
using std::cout;
using std::endl;


SCENARIO("Switch active high reset from high to low and output from low to high") {
    GIVEN("A module with a high reset input") {
        Testbench *top = new Testbench(true);
        top->open_trace("trace/trace.vcd");
        top->m_core->i_reset = 1;
        REQUIRE(top->m_core->i_reset == 1);
        REQUIRE(top->m_core->o_out == 0);
        top->tick();

        WHEN("Reset transitions to low") {
            top->reset();
            REQUIRE(top->m_core->i_reset == 0);
            top->tick();

            THEN("The output signal is pulled high") {
                CHECK(top->m_core->o_out == 1);
            }
        }
    }
}


int main(int argc, char **argv, char **env) {
    // Initialize Verilator
    Verilated::commandArgs(argc, argv);
    // Testbench *top = new Testbench(true);
    cout<<"Module : MODULENAME : Running Tests"<<endl;
    // Doctest initialization
    doctest::Context context;
    context.applyCommandLine(argc, argv);
    int res = context.run(); // run queries, or run tests unless --no-run is specified
    if(context.shouldExit()) // important - query flags (and --exit) rely on the user doing this
        return res;          // propagate the result of the tests

    // exit(0);
    return res ;
}
